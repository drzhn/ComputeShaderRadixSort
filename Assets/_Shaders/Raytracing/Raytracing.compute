#pragma use_dxc
#pragma kernel Raytracing

#include <UnityShaderVariables.cginc>
#include <Assets/_Shaders/Constants.cginc>

StructuredBuffer<uint> sortedTriangleIndices; // size = THREADS_PER_BLOCK * BLOCK_SIZE
StructuredBuffer<AABB> triangleAABB; // size = THREADS_PER_BLOCK * BLOCK_SIZE
StructuredBuffer<InternalNode> internalNodes; // size = THREADS_PER_BLOCK * BLOCK_SIZE - 1
StructuredBuffer<LeafNode> leafNodes; // size = THREADS_PER_BLOCK * BLOCK_SIZE
StructuredBuffer<AABB> bvhData; // size = THREADS_PER_BLOCK * BLOCK_SIZE - 1
StructuredBuffer<Triangle> triangleData; // size = THREADS_PER_BLOCK * BLOCK_SIZE

RWTexture2D<float4> _texture;

uniform int indexToCheck;
uniform int screenWidth;
uniform int screenHeight;
uniform float cameraFov;
uniform float4x4 cameraToWorldMatrix;

struct Ray
{
    float3 origin;
    float3 dir;
    float3 inv_dir;
};

struct RaycastResult
{
    float distance;
    int hasResult;
};

float RayTriangleIntersection(float3 orig, float3 dir, float3 v0, float3 v1, float3 v2)
{
    float3 e1 = v1 - v0;
    float3 e2 = v2 - v0;

    float3 pvec = cross(dir, e2);
    float det = dot(e1, pvec);

    if (det < 1e-8 && det > -1e-8)
    {
        return 0;
    }

    float inv_det = 1 / det;
    float3 tvec = orig - v0;
    float u = dot(tvec, pvec) * inv_det;
    if (u < 0 || u > 1)
    {
        return 0;
    }

    float3 qvec = cross(tvec, e1);
    float v = dot(dir, qvec) * inv_det;
    if (v < 0 || u + v > 1)
    {
        return 0;
    }
    return dot(e2, qvec) * inv_det;
}

bool RayBoxIntersection(AABB b, Ray r)
{
    const float3 t1 = (b.min - r.origin) * r.inv_dir;
    const float3 t2 = (b.max - r.origin) * r.inv_dir;

    const float3 tmin1 = min(t1, t2);
    const float3 tmax1 = max(t1, t2);

    const float tmin = max(tmin1.x, max(tmin1.y, tmin1.z));
    const float tmax = min(tmax1.x, min(tmax1.y, tmax1.z));

    return tmax > tmin;
}

RaycastResult CheckTriangle(uint triangleIndex, Ray ray, RaycastResult currentResult)
{
    RaycastResult result = currentResult;
    if (RayBoxIntersection(triangleAABB[triangleIndex], ray))
    {
        const Triangle t = triangleData[triangleIndex];
        const float dist = RayTriangleIntersection(ray.origin, ray.dir, t.a, t.b, t.c);
        if (dist != 0)
        {
            result.distance = min(result.distance, dist);
            result.hasResult = 1;
        }
    }

    return result;
}

[numthreads(32,32,1)]
void Raytracing(uint3 id : SV_DispatchThreadID)
{
    const float near = _ProjectionParams.y;
    const float fov = cameraFov;
    const float height = 2 * near * fov;
    const float width = screenWidth * height / screenHeight;

    // float3 v0 = float3(0, 0, 0);
    // float3 v1 = float3(2, 0, 0);
    // float3 v2 = float3(0, 1, 0);

    float3 origin = float3(0, 0, 0);
    float3 dir = float3(
        -width / 2 + width * id.x / screenWidth,
        -height / 2 + height * id.y / screenHeight,
        -near
    );

    origin = mul(cameraToWorldMatrix, float4(origin, 1)).xyz;
    dir = mul(cameraToWorldMatrix, float4(dir, 0)).xyz;

    Ray ray;
    ray.origin = origin;
    ray.dir = dir;
    ray.inv_dir = 1 / dir;

    RaycastResult result;
    result.distance = 0x7F7FFFFF;
    result.hasResult = 0;

    // AABB test;
    // test.min = float3(-1, -1, -1);
    // test.max = float3(1, 1, 1);
    // result.hasResult = RayBoxIntersection(test, ray) ? 1 : 0;


    uint stack[64];
    uint currentStackIndex = 0;
    stack[currentStackIndex] = 0;
    currentStackIndex = 1;

    // _texture[id.xy] = float4(1, 0, 0, RayBoxIntersection(bvhData[indexToCheck], ray));
    // // _texture[id.xy] = float4(1, 0, 0, RayBoxIntersection(triangleAABB[indexToCheck], ray));
    // return;

    while (currentStackIndex != 0)
    {
        currentStackIndex --;
        const uint index = stack[currentStackIndex];

        if (!RayBoxIntersection(bvhData[index], ray))
        {
            continue;
        }

        const uint leftIndex = internalNodes[index].leftNode;
        const uint leftType = internalNodes[index].leftNodeType;

        if (leftType == INTERNAL_NODE)
        {
            stack[currentStackIndex] = leftIndex;
            currentStackIndex++;
        }
        else
        {
            const uint triangleIndex = sortedTriangleIndices[leafNodes[leftIndex].index];
            result = CheckTriangle(triangleIndex, ray, result);
            // result.hasResult = 1;
        }

        const uint rightIndex = internalNodes[index].rightNode;
        const uint rightType = internalNodes[index].rightNodeType;


        if (rightType == INTERNAL_NODE)
        {
            stack[currentStackIndex] = rightIndex;
            currentStackIndex ++;
        }
        else
        {
            const uint triangleIndex = sortedTriangleIndices[leafNodes[rightIndex].index];
            result = CheckTriangle(triangleIndex, ray, result);
            // result.hasResult = 1;
        }
    }

    // _texture[id.xy] = float4(1, 0, 0, saturate(RayTriangleIntersection(origin, dir, v0, v1, v2)));
    _texture[id.xy] = float4(1, 0, 0, result.hasResult);
}
