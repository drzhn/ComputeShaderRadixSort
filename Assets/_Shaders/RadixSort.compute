#pragma use_dxc
#pragma kernel CSMain

#include <Assets/_Shaders/Constants.cginc>

RWStructuredBuffer<uint> data; // size = THREADS_PER_BLOCK

RWStructuredBuffer<uint> offsetsData; // size = BLOCK_SIZE * BUCKET_SIZE
RWStructuredBuffer<uint> sizesData; // size = BLOCK_SIZE * BUCKET_SIZE


groupshared uint sortTile[THREADS_PER_BLOCK];
groupshared uint scanTile[WARP_SIZE];
groupshared uint falseTotal;

groupshared uint radixTile[THREADS_PER_BLOCK];
groupshared uint offsetsTile[BUCKET_SIZE];
groupshared uint sizesTile[BUCKET_SIZE];


inline uint intraBlockScan(uint threadId, bool pred0)
{
    const uint warpIdx = threadId / WARP_SIZE;
    const uint laneIdx = threadId % WARP_SIZE;
    const uint warpResult = WavePrefixCountBits(pred0);
    const uint predResult = pred0;

    GroupMemoryBarrierWithGroupSync();
    if (laneIdx == WARP_SIZE - 1)
    {
        scanTile[warpIdx] = warpResult + predResult;
    }
    GroupMemoryBarrierWithGroupSync();

    if (threadId < WARP_SIZE)
    {
        const uint prefixSum = scanTile[threadId];
        scanTile[threadId] = WavePrefixSum(prefixSum);
    }
    GroupMemoryBarrierWithGroupSync();

    return warpResult + scanTile[warpIdx];
}

[numthreads(THREADS_PER_BLOCK,1,1)]
void CSMain(uint3 tid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
    const uint bitOffset = 0;

    const uint threadId = tid.x;
    const uint groupId = gid.x;

    sortTile[threadId] = data[groupId * THREADS_PER_BLOCK + threadId];

    GroupMemoryBarrierWithGroupSync();
    
    for (uint shift = 0; shift < RADIX; shift++)
    {
        uint predResult = 0;
    
        uint el0 = sortTile[threadId];
        bool pred0 = (el0 >> shift) & 1;
    
        predResult += pred0;
    
        GroupMemoryBarrierWithGroupSync();
    
        const uint trueBefore = intraBlockScan(threadId, pred0);
    
        GroupMemoryBarrierWithGroupSync();
    
        if (threadId == THREADS_PER_BLOCK - 1)
        {
            falseTotal = THREADS_PER_BLOCK - (trueBefore + predResult);
        }
        GroupMemoryBarrierWithGroupSync();
    
        sortTile[pred0 ? trueBefore + falseTotal : threadId - trueBefore] = el0;
    
        GroupMemoryBarrierWithGroupSync();
    }
    
    data[groupId * THREADS_PER_BLOCK + threadId] = sortTile[threadId];
    
    radixTile[threadId] = (sortTile[threadId] >> bitOffset) & (BUCKET_SIZE - 1);
    
    if (threadId < BUCKET_SIZE)
    {
        offsetsTile[threadId] = 0;
        sizesTile[threadId] = 0;
    }
    GroupMemoryBarrierWithGroupSync();
    
    if (threadId > 0 && radixTile[threadId - 1] != radixTile[threadId])
    {
        offsetsTile[radixTile[threadId]] = threadId;
    }
    GroupMemoryBarrierWithGroupSync();
    
    if (threadId > 0 && radixTile[threadId - 1] != radixTile[threadId])
    {
        uint radix = radixTile[threadId - 1];
        sizesTile[radix] = threadId - offsetsTile[radix];
    }
    if (threadId == THREADS_PER_BLOCK - 1)
    {
        sizesTile[BUCKET_SIZE - 1] = THREADS_PER_BLOCK - offsetsTile[BUCKET_SIZE - 1];
    }
    
    GroupMemoryBarrierWithGroupSync();
    if (threadId < BUCKET_SIZE)
    {
        offsetsData[groupId + threadId * BLOCK_SIZE] = offsetsTile[threadId]; //  groupId * BLOCK_SIZE + threadId ???   
        sizesData[groupId + threadId * BLOCK_SIZE] = sizesTile[threadId]; 
    }
}
